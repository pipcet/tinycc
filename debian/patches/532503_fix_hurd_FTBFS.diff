From: Thomas Preud'homme <thomas.preudhomme@celest.fr>
Date: Tue, 30 Mar 2010 09:45:31 +0200
Subject: [PATCH] 532503_fix_hurd_FTBFS.diff
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

* Configure handle both i386-AT386 and i686-AT386 arch
* Better handle ld scripts:
    - search file from INPUT and GROUP command in current directory and
      in the library path
    - handle libraries specified by -lfoo options
---
 configure |    2 +-
 tccelf.c  |   90 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 89 insertions(+), 3 deletions(-)

diff --git a/configure b/configure
index f7d7ac1..2010f1b 100755
--- a/configure
+++ b/configure
@@ -35,7 +35,7 @@ host_cc="gcc"
 ar="ar"
 cpu=`uname -m`
 case "$cpu" in
-  i386|i486|i586|i686|i86pc|BePC|i686-AT386)
+  i386|i486|i586|i686|i86pc|BePC|i386-AT386|i686-AT386)
     cpu="x86"
   ;;
   x86_64)
diff --git a/tccelf.c b/tccelf.c
index 4020e24..8549057 100644
--- a/tccelf.c
+++ b/tccelf.c
@@ -1274,6 +1274,8 @@ static void tcc_add_linker_symbols(TCCState *s1)
 /* name of ELF interpreter */
 #if defined __FreeBSD__
 static char elf_interp[] = "/usr/libexec/ld-elf.so.1";
+#elif defined __gnu_hurd__
+static char elf_interp[] = "/lib/ld.so";
 #elif defined TCC_ARM_EABI
 static char elf_interp[] = "/lib/ld-linux.so.3";
 #elif defined(TCC_TARGET_X86_64)
@@ -2652,9 +2654,77 @@ static int ld_next(TCCState *s1, char *name, int name_size)
     return c;
 }
 
+/*
+ * Extract the library name from the file name
+ * Return 0 if the file isn't a library
+ *
+ * /!\ No test on filename capacity, be careful
+ */
+static int filename_to_libname(TCCState *s1, char filename[], char libname[])
+{
+    char *ext, *base;
+    int libprefix;
+
+    /* already converted to library name */
+    if (filename[0] == '\0')
+        return 1;
+    base = tcc_basename(filename);
+    if (base != filename)
+        return 0;
+    ext = strrchr(base, '.');
+    if (ext == NULL)
+        return 0;
+    ext++;
+    libprefix = !strncmp(filename, "lib", 3);
+    if (!s1->static_link) {
+#ifdef TCC_TARGET_PE
+        if (!strncmp(ext, "def", 3)) {
+            *(--ext) = '\0';
+            strcpy(libname, filename);
+            *ext = '.';
+            return 1;
+        }
+#else
+        if (libprefix && (!strncmp(ext, "so", 2))) {
+            *(--ext) = '\0';
+            strcpy(libname, filename + 3);
+            *ext = '.';
+            return 1;
+        }
+#endif
+    } else {
+        if (libprefix && (!strncmp(ext, "a", 1))) {
+            *(--ext) = '\0';
+            strcpy(libname, filename + 3);
+            *ext = '.';
+            return 1;
+        }
+    }
+    return 0;
+}
+
+/*
+ * Extract the file name from the library name
+ *
+ * /!\ No test on filename capacity, be careful
+ */
+static void libname_to_filename(TCCState *s1, char libname[], char filename[])
+{
+    if (!s1->static_link) {
+#ifdef TCC_TARGET_PE
+        snprintf(filename, strlen(libname) + 5, "%s.def", libname);
+#else
+        snprintf(filename, strlen(libname) + 7, "lib%s.so", libname);
+#endif
+    } else {
+        snprintf(filename, strlen(libname) + 6, "lib%s.a", libname);
+    }
+}
+
 static int ld_add_file_list(TCCState *s1, int as_needed)
 {
     char filename[1024];
+    char libname[1024];
     int t, ret;
 
     t = ld_next(s1, filename, sizeof(filename));
@@ -2662,11 +2732,20 @@ static int ld_add_file_list(TCCState *s1, int as_needed)
         expect("(");
     t = ld_next(s1, filename, sizeof(filename));
     for(;;) {
+        libname[0] = '\0';
         if (t == LD_TOK_EOF) {
             error_noabort("unexpected end of file");
             return -1;
         } else if (t == ')') {
             break;
+        } else if (t == '-') {
+            t = ld_next(s1, filename, sizeof(filename));
+            if ((t != LD_TOK_NAME) || (filename[0] != 'l')) {
+                error_noabort("library name expected");
+                return -1;
+            }
+            strcpy(libname, &filename[1]);
+            libname_to_filename(s1, libname, filename);
         } else if (t != LD_TOK_NAME) {
             error_noabort("filename expected");
             return -1;
@@ -2677,8 +2756,15 @@ static int ld_add_file_list(TCCState *s1, int as_needed)
                 return ret;
         } else {
             /* TODO: Implement AS_NEEDED support. Ignore it for now */
-            if (!as_needed)
-                tcc_add_file(s1, filename);
+            if (!as_needed) {
+                ret = tcc_add_file_internal(s1, filename, 0);
+                if (ret) {
+                    if (filename_to_libname(s1, filename, libname))
+                        ret = tcc_add_library(s1, libname);
+                    if (ret)
+                        return ret;
+		}
+            }
         }
         t = ld_next(s1, filename, sizeof(filename));
         if (t == ',') {
-- 
