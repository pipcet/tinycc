From 56283ce671fadbc011fc1e3f9619bdbed1a4f44c Mon Sep 17 00:00:00 2001
From: Joe Soroka <gits@joesoroka.com>
Date: Wed, 13 Apr 2011 22:45:30 +0200
Subject: Implement C99 Variable Length Arrays

Implement C99 Variable Length Arrays in tinycc:
- Support VLA with multiple level (nested vla)
- Update documentation with regards to VT_VLA
- Add a testsuite in tcctest.c

Origin: commit: ace0f7f2598f5e9d9d2ad8999e3140b8535d9459 to 7391cf01a726b41e18c6f64d3befeefd34d24496
Forwarded: commit: ace0f7f2598f5e9d9d2ad8999e3140b8535d9459 to 7391cf01a726b41e18c6f64d3befeefd34d24496
Last-Update: 2011-05-12
Applied-Upstream: commit: ace0f7f2598f5e9d9d2ad8999e3140b8535d9459 to 7391cf01a726b41e18c6f64d3befeefd34d24496
---
 Changelog       |    4 ++
 TODO            |    1 -
 libtcc.c        |   10 ++++
 tcc-doc.texi    |   18 ++++++-
 tcc.h           |    3 +-
 tccgen.c        |  136 ++++++++++++++++++++++++++++++++++++++++++++++---------
 tccpp.c         |   31 +++++++++++++
 tcctok.h        |    2 +
 tests/tcctest.c |   59 ++++++++++++++++++++++++
 9 files changed, 238 insertions(+), 26 deletions(-)

diff --git a/Changelog b/Changelog
index b271054..3e0e04c 100644
--- a/Changelog
+++ b/Changelog
@@ -1,3 +1,7 @@
+not released:
+
+- Add support for C99 variable length arrays (Thomas Preud'homme + Joe Soroka)
+
 version 0.9.25:
 
 - first support for x86-64 target (Shinichiro Hamaji)
diff --git a/TODO b/TODO
index 6f49c5d..760c576 100644
--- a/TODO
+++ b/TODO
@@ -49,7 +49,6 @@ Missing features:
 - add '-MD' option
 - atexit (Nigel Horne)
 - packed attribute
-- C99: add variable size arrays (gcc 3.2 testsuite issue)
 - C99: add complex types (gcc 3.2 testsuite issue)
 - postfix compound literals (see 20010124-1.c)
 
diff --git a/libtcc.c b/libtcc.c
index 31914f7..cffa447 100644
--- a/libtcc.c
+++ b/libtcc.c
@@ -40,6 +40,8 @@ static int tok_flags;
 #define TOK_FLAG_EOF   0x0008 /* end of file */
 
 static int *macro_ptr, *macro_ptr_allocated;
+static int *user_macro_ptr;
+static int user_saved_buffer[TOK_MAX_SIZE + 1];
 static int *unget_saved_macro_ptr;
 static int unget_saved_buffer[TOK_MAX_SIZE + 1];
 static int unget_buffer_enabled;
@@ -126,9 +128,12 @@ char *get_tok_str(int v, CValue *cv);
 static void parse_expr_type(CType *type);
 static void expr_type(CType *type);
 static void unary_type(CType *type);
+static void vla_runtime_type_size(CType *type, int *a);
 static void block(int *bsym, int *csym, int *case_sym, int *def_sym, 
                   int case_reg, int is_expr);
 static int expr_const(void);
+/* varray */
+static int expr_check_const(void);
 static void expr_eq(void);
 static void gexpr(void);
 static void gen_inline_functions(void);
@@ -1135,6 +1140,7 @@ void tcc_close(BufferedFile *bf)
 static int tcc_compile(TCCState *s1)
 {
     Sym *define_start;
+    SValue *pvtop;
     char buf[512];
     volatile int section_sym;
 
@@ -1212,10 +1218,13 @@ static int tcc_compile(TCCState *s1)
         ch = file->buf_ptr[0];
         tok_flags = TOK_FLAG_BOL | TOK_FLAG_BOF;
         parse_flags = PARSE_FLAG_PREPROCESS | PARSE_FLAG_TOK_NUM;
+        pvtop = vtop;
         next();
         decl(VT_CONST);
         if (tok != TOK_EOF)
             expect("declaration");
+        if (pvtop != vtop)
+            warning("internal compiler error: vstack leak? (%d)", vtop - pvtop);
 
         /* end of translation unit info */
         if (s1->do_debug) {
@@ -1223,6 +1232,7 @@ static int tcc_compile(TCCState *s1)
                         text_section->data_offset, text_section, section_sym);
         }
     }
+
     s1->error_set_jmp_enabled = 0;
 
     /* reset define stack, but leave -Dsymbols (may be incorrect if
diff --git a/tcc-doc.texi b/tcc-doc.texi
index e47c917..9acde05 100644
--- a/tcc-doc.texi
+++ b/tcc-doc.texi
@@ -916,10 +916,14 @@ be the best solution.
 #define VT_LLONG     12  /* 64 bit integer */
 #define VT_LONG      13  /* long integer (NEVER USED as type, only
                             during parsing) */
-#define VT_BTYPE      0x000f /* mask for basic type */
+#define VT_BTYPE      0x000f  /* mask for basic type */
 #define VT_UNSIGNED   0x0010  /* unsigned type */
 #define VT_ARRAY      0x0020  /* array type (also has VT_PTR) */
+#define VT_VLA        0x4000  /* VLA type (also has VT_PTR and VT_ARRAY) */
 #define VT_BITFIELD   0x0040  /* bitfield modifier */
+#define VT_CONSTANT   0x0800  /* const modifier */
+#define VT_VOLATILE   0x1000  /* volatile modifier */
+#define VT_SIGNED     0x2000  /* signed type */
 
 #define VT_STRUCT_SHIFT 16   /* structure/enum name shift (16 bits left) */
 @end example
@@ -932,7 +936,8 @@ The @code{VT_UNSIGNED} flag can be set for chars, shorts, ints and long
 longs.
 
 Arrays are considered as pointers @code{VT_PTR} with the flag
-@code{VT_ARRAY} set.
+@code{VT_ARRAY} set. Variable length arrays are considered as special
+arrays and have flag @code{VT_VLA} set instead of @code{VT_ARRAY}.
 
 The @code{VT_BITFIELD} flag can be set for chars, shorts, ints and long
 longs. If it is set, then the bitfield position is stored from bits
@@ -948,6 +953,10 @@ integer:
 #define VT_EXTERN  0x00000080  /* extern definition */
 #define VT_STATIC  0x00000100  /* static variable */
 #define VT_TYPEDEF 0x00000200  /* typedef definition */
+#define VT_INLINE  0x00000400  /* inline definition */
+#define VT_IMPORT  0x00004000  /* win32: extern data imported from dll */
+#define VT_EXPORT  0x00008000  /* win32: data exported from dll */
+#define VT_WEAK    0x00010000  /* win32: data exported from dll */
 @end example
 
 @section Symbols
@@ -959,7 +968,10 @@ contains @code{Sym} structures.
 an idenfier is also a token, so a string is never necessary to store
 it). @code{Sym.t} gives the type of the symbol. @code{Sym.r} is usually
 the register in which the corresponding variable is stored. @code{Sym.c} is
-usually a constant associated to the symbol.
+usually a constant associated to the symbol like its address for normal
+symbols, and the number of entries for symbols representing arrays.
+Variable length array types use @code{Sym.c} as a location on the stack
+which holds the runtime sizeof for the type.
 
 Four main symbol stacks are defined:
 
diff --git a/tcc.h b/tcc.h
index 4eccd23..ae3e291 100644
--- a/tcc.h
+++ b/tcc.h
@@ -140,7 +140,7 @@ typedef int BOOL;
 
 #define TOK_HASH_SIZE       8192 /* must be a power of two */
 #define TOK_ALLOC_INCR      512  /* must be a power of two */
-#define TOK_MAX_SIZE        4 /* token max size in int unit when stored in string */
+#define TOK_MAX_SIZE        31 /* token max size in int unit when stored in string */
 
 /* token symbol management */
 typedef struct TokenSym {
@@ -531,6 +531,7 @@ struct TCCState {
 #define VT_BTYPE      0x000f /* mask for basic type */
 #define VT_UNSIGNED   0x0010  /* unsigned type */
 #define VT_ARRAY      0x0020  /* array type (also has VT_PTR) */
+#define VT_VLA        0x4000  /* VLA type (also has VT_PTR and VT_ARRAY) */
 #define VT_BITFIELD   0x0040  /* bitfield modifier */
 #define VT_CONSTANT   0x0800  /* const modifier */
 #define VT_VOLATILE   0x1000  /* volatile modifier */
diff --git a/tccgen.c b/tccgen.c
index fee07ae..5b1ad67 100644
--- a/tccgen.c
+++ b/tccgen.c
@@ -1196,6 +1196,12 @@ static int pointed_size(CType *type)
     return type_size(pointed_type(type), &align);
 }
 
+static void vla_runtime_pointed_size(CType *type)
+{
+    int align;
+    vla_runtime_type_size(pointed_type(type), &align);
+}
+
 static inline int is_null_pointer(SValue *p)
 {
     if ((p->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST)
@@ -1288,7 +1294,12 @@ void gen_op(int op)
                 error("cannot use pointers here");
             check_comparison_pointer_types(vtop - 1, vtop, op);
             /* XXX: check that types are compatible */
-            u = pointed_size(&vtop[-1].type);
+            if (vtop[-1].type.t & VT_VLA) {
+                vla_runtime_pointed_size(&vtop[-1].type);
+            } else {
+                vpushi(pointed_size(&vtop[-1].type));
+            }
+            vrott(3);
             gen_opic(op);
             /* set to integer type */
 #ifdef TCC_TARGET_X86_64
@@ -1296,7 +1307,7 @@ void gen_op(int op)
 #else
             vtop->type.t = VT_INT; 
 #endif
-            vpushi(u);
+            vswap();
             gen_op(TOK_PDIV);
         } else {
             /* exactly one pointer : must be '+' or '-'. */
@@ -1308,12 +1319,20 @@ void gen_op(int op)
                 swap(&t1, &t2);
             }
             type1 = vtop[-1].type;
+            type1.t &= ~VT_ARRAY;
+            if (vtop[-1].type.t & VT_VLA)
+                vla_runtime_pointed_size(&vtop[-1].type);
+            else {
+                u = pointed_size(&vtop[-1].type);
+                if (u < 0)
+                    error("unknown array element size");
 #ifdef TCC_TARGET_X86_64
-            vpushll(pointed_size(&vtop[-1].type));
+                vpushll(u);
 #else
-            /* XXX: cast to int ? (long long case) */
-            vpushi(pointed_size(&vtop[-1].type));
+                /* XXX: cast to int ? (long long case) */
+                vpushi(u);
 #endif
+            }
             gen_op('*');
 #ifdef CONFIG_TCC_BCHECK
             /* if evaluating constant expression, no code should be
@@ -1663,7 +1682,7 @@ static void gen_cast(CType *type)
     vtop->type = *type;
 }
 
-/* return type size. Put alignment at 'a' */
+/* return type size as known at compile time. Put alignment at 'a' */
 static int type_size(CType *type, int *a)
 {
     Sym *s;
@@ -1723,6 +1742,17 @@ static int type_size(CType *type, int *a)
     }
 }
 
+/* push type size as known at runtime time on top of value stack. Put
+   alignment at 'a' */
+static void vla_runtime_type_size(CType *type, int *a)
+{
+    if (type->t & VT_VLA) {
+        vset(&int_type, VT_LOCAL|VT_LVAL, type->ref->c);
+    } else {
+        vpushi(type_size(type, a));
+    }
+}
+
 /* return the pointed type of t */
 static inline CType *pointed_type(CType *type)
 {
@@ -2747,7 +2777,7 @@ static void post_type(CType *type, AttributeDef *ad)
         FUNC_ARGS(ad->func_attr) = arg_size;
         s = sym_push(SYM_FIELD, type, ad->func_attr, l);
         s->next = first;
-        type->t = t1 | VT_FUNC;
+        type->t = VT_FUNC;
         type->ref = s;
     } else if (tok == '[') {
         /* array definition */
@@ -2755,21 +2785,44 @@ static void post_type(CType *type, AttributeDef *ad)
         if (tok == TOK_RESTRICT1)
             next();
         n = -1;
+        t1 = 0;
         if (tok != ']') {
-            n = expr_const();
-            if (n < 0)
-                error("invalid array size");    
+            gexpr();
+            if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) == VT_CONST) {
+                n = vtop->c.i;
+                if (n < 0)
+                    error("invalid array size");
+            } else if (!local_stack) {
+                error("expected constant expression (variably modified array at file scope)");
+            } else {
+                if (!is_integer_btype(vtop->type.t & VT_BTYPE))
+                    error("size of variable length array should be an integer");
+                t1 = VT_VLA;
+            }
         }
         skip(']');
         /* parse next post type */
-        t1 = type->t & VT_STORAGE;
-        type->t &= ~VT_STORAGE;
         post_type(type, ad);
+        t1 |= type->t & VT_VLA;
         
-        /* we push a anonymous symbol which will contain the array
+        if (t1 & VT_VLA) {
+            loc -= type_size(&int_type, &align);
+            loc &= -align;
+            n = loc;
+
+            vla_runtime_type_size(type, &align);
+            gen_op('*');
+            vset(&int_type, VT_LOCAL|VT_LVAL, loc);
+            vswap();
+            vstore();
+        }
+        if (n != -1)
+            vpop();
+
+        /* we push an anonymous symbol which will contain the array
            element type */
         s = sym_push(SYM_FIELD, type, 0, n);
-        type->t = t1 | VT_ARRAY | VT_PTR;
+        type->t = (t1 ? VT_VLA : VT_ARRAY) | VT_PTR;
         type->ref = s;
     }
 }
@@ -2784,7 +2837,7 @@ static void type_decl(CType *type, AttributeDef *ad, int *v, int td)
 {
     Sym *s;
     CType type1, *type2;
-    int qualifiers;
+    int qualifiers, storage;
     
     while (tok == '*') {
         qualifiers = 0;
@@ -2836,7 +2889,10 @@ static void type_decl(CType *type, AttributeDef *ad, int *v, int td)
             *v = 0;
         }
     }
+    storage = type->t & VT_STORAGE;
+    type->t &= ~VT_STORAGE;
     post_type(type, ad);
+    type->t |= storage;
     if (tok == TOK_ATTRIBUTE1 || tok == TOK_ATTRIBUTE2)
         parse_attribute(ad);
     if (!type1.t)
@@ -2883,7 +2939,7 @@ static void indir(void)
         gv(RC_INT);
     vtop->type = *pointed_type(&vtop->type);
     /* Arrays and functions are never lvalues */
-    if (!(vtop->type.t & VT_ARRAY)
+    if (!(vtop->type.t & VT_ARRAY) && !(vtop->type.t & VT_VLA)
         && (vtop->type.t & VT_BTYPE) != VT_FUNC) {
         vtop->r |= lvalue_type(vtop->type.t);
         /* if bound checking, the referenced pointer must be checked */
@@ -3132,9 +3188,13 @@ static void unary(void)
         unary_type(&type); // Perform a in_sizeof = 0;
         size = type_size(&type, &align);
         if (t == TOK_SIZEOF) {
-            if (size < 0)
-                error("sizeof applied to an incomplete type");
-            vpushi(size);
+            if (!(type.t & VT_VLA)) {
+                if (size < 0)
+                    error("sizeof applied to an incomplete type");
+                vpushi(size);
+            } else {
+                vla_runtime_type_size(&type, &align);
+            }
         } else {
             vpushi(align);
         }
@@ -3777,6 +3837,19 @@ static int expr_const(void)
     return c;
 }
 
+/* varray */
+static int expr_check_const(void)
+{
+    int last_tok = tok;
+    expr_const1();
+    if ((vtop->r & (VT_VALMASK | VT_LVAL | VT_SYM)) != VT_CONST) {
+        unget_tok(last_tok);
+        return(FALSE);
+    }
+    return(TRUE);
+}
+/* ~varray */
+
 /* return the label token if current token is a label, otherwise
    return zero */
 static int is_label(void)
@@ -4386,7 +4459,26 @@ static void decl_initializer(CType *type, Section *sec, unsigned long c,
     Sym *s, *f;
     CType *t1;
 
-    if (type->t & VT_ARRAY) {
+    if (type->t & VT_VLA) {
+#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
+        int a;
+        CValue retcval;
+
+        vpush_global_sym(&func_old_type, TOK_alloca);
+        vla_runtime_type_size(type, &a);
+        gfunc_call(1);
+
+        /* return value */
+        retcval.i = 0;
+        vsetc(type, REG_IRET, &retcval);
+        vset(type, VT_LOCAL|VT_LVAL, c);
+        vswap();
+        vstore();
+        vpop();
+#else
+        error("variable length arrays unsupported for this target");
+#endif
+    } else if (type->t & VT_ARRAY) {
         s = type->ref;
         n = s->c;
         array_length = 0;
@@ -4787,7 +4879,7 @@ static void decl_initializer_alloc(CType *type, AttributeDef *ad, int r,
             bounds_ptr[1] = size;
         }
     }
-    if (has_init) {
+    if (has_init || (type->t & VT_VLA)) {
         decl_initializer(type, sec, addr, 1, 0);
         /* restore parse state if needed */
         if (init_str.str) {
@@ -5107,6 +5199,8 @@ static void decl(int l)
                     if (!(type.t & VT_ARRAY))
                         r |= lvalue_type(type.t);
                     has_init = (tok == '=');
+                    if (has_init && (type.t & VT_VLA))
+                        error("Variable length array cannot be initialized");
                     if ((btype.t & VT_EXTERN) || 
                         ((type.t & VT_ARRAY) && (type.t & VT_STATIC) &&
                          !has_init && l == VT_CONST && type.ref->c < 0)) {
diff --git a/tccpp.c b/tccpp.c
index ff17d8b..4b8afd7 100644
--- a/tccpp.c
+++ b/tccpp.c
@@ -2846,6 +2846,37 @@ static inline void unget_tok(int last_tok)
     tok = last_tok;
 }
 
+/* varray */
+static inline void put_user_tok_start()
+{
+    user_macro_ptr = user_saved_buffer;
+}
+
+static inline void put_user_tok_end()
+{
+    const int user_tok_size = (uint32_t)user_macro_ptr - (uint32_t)user_saved_buffer;
+
+    *user_macro_ptr = 0;
+    unget_buffer_enabled = 1;
+    if (macro_ptr) {
+        memmove((uint8_t*)macro_ptr+user_tok_size, macro_ptr, user_tok_size-1);
+        memcpy(macro_ptr, user_saved_buffer, user_tok_size-1);
+    } else {
+        macro_ptr = user_saved_buffer;
+    }
+}
+
+static inline void put_user_tok(int last_tok)
+{
+    int i, n;
+
+    *user_macro_ptr++ = last_tok;
+    n = tok_ext_size(tok) - 1;
+    for(i=0;i<n;i++)
+        *user_macro_ptr++ = tokc.tab[i];
+}
+/* ~varray */
+
 
 /* better than nothing, but needs extension to handle '-E' option
    correctly too */
diff --git a/tcctok.h b/tcctok.h
index 6dc4778..9e61761 100644
--- a/tcctok.h
+++ b/tcctok.h
@@ -228,6 +228,8 @@
      DEF(TOK_memmove, "memmove")
      DEF(TOK_strlen, "strlen")
      DEF(TOK_strcpy, "strcpy")
+#endif
+#if defined TCC_TARGET_I386 || defined TCC_TARGET_X86_64
      DEF(TOK_alloca, "alloca")
 #endif
 
diff --git a/tests/tcctest.c b/tests/tcctest.c
index a2d481a..d0de213 100644
--- a/tests/tcctest.c
+++ b/tests/tcctest.c
@@ -76,6 +76,7 @@ void whitespace_test(void);
 void relocation_test(void);
 void old_style_function(void);
 void alloca_test(void);
+void c99_vla_test(int size1, int size2);
 void sizeof_test(void);
 void typeof_test(void);
 void local_label_test(void);
@@ -531,6 +532,7 @@ int main(int argc, char **argv)
     relocation_test();
     old_style_function();
     alloca_test();
+    c99_vla_test(5, 2);
     sizeof_test();
     typeof_test();
     statement_expr_test();
@@ -1949,6 +1951,63 @@ void alloca_test()
 #endif
 }
 
+void *bounds_checking_is_enabled()
+{
+    char ca[10], *cp = ca-1;
+    return (ca != cp + 1) ? cp : NULL;
+}
+
+void c99_vla_test(int size1, int size2)
+{
+#if defined __i386__ || defined __x86_64__
+    int size = size1 * size2;
+    int tab1[size][2], tab2[10][2];
+    void *tab1_ptr, *tab2_ptr, *bad_ptr;
+
+    /* "size" should have been 'captured' at tab1 declaration,
+        so modifying it should have no effect on VLA behaviour. */
+    size = size-1;
+
+    printf("Test C99 VLA 1 (sizeof): ");
+    printf("%s\n", (sizeof tab1 == size1 * size2 * 2 * sizeof(int)) ? "PASSED" : "FAILED");
+    tab1_ptr = tab1;
+    tab2_ptr = tab2;
+    printf("Test C99 VLA 2 (ptrs substract): ");
+    printf("%s\n", (tab2 - tab1 == (tab2_ptr - tab1_ptr) / (sizeof(int) * 2)) ? "PASSED" : "FAILED");
+    printf("Test C99 VLA 3 (ptr add): ");
+    printf("%s\n", &tab1[5][1] == (tab1_ptr + (5 * 2 + 1) * sizeof(int)) ? "PASSED" : "FAILED");
+    printf("Test C99 VLA 4 (ptr access): ");
+    tab1[size1][1] = 42;
+    printf("%s\n", (*((int *) (tab1_ptr + (size1 * 2 + 1) * sizeof(int))) == 42) ? "PASSED" : "FAILED");
+
+    printf("Test C99 VLA 5 (bounds checking (might be disabled)): ");
+    if (bad_ptr = bounds_checking_is_enabled()) {
+        int *t1 = &tab1[size1 * size2 - 1][3];
+        int *t2 = &tab2[9][3];
+        printf("%s ", bad_ptr == t1 ? "PASSED" : "FAILED");
+        printf("%s ", bad_ptr == t2 ? "PASSED" : "FAILED");
+
+        char*c1 = 1 + sizeof(tab1) + (char*)tab1;
+        char*c2 = 1 + sizeof(tab2) + (char*)tab2;
+        printf("%s ", bad_ptr == c1 ? "PASSED" : "FAILED");
+        printf("%s ", bad_ptr == c2 ? "PASSED" : "FAILED");
+
+        int *i1 = tab1[-1];
+        int *i2 = tab2[-1];
+        printf("%s ", bad_ptr == i1 ? "PASSED" : "FAILED");
+        printf("%s ", bad_ptr == i2 ? "PASSED" : "FAILED");
+
+        int *x1 = tab1[size1 * size2 + 1];
+        int *x2 = tab2[10 + 1];
+        printf("%s ", bad_ptr == x1 ? "PASSED" : "FAILED");
+        printf("%s ", bad_ptr == x2 ? "PASSED" : "FAILED");
+    } else {
+        printf("PASSED PASSED PASSED PASSED PASSED PASSED PASSED PASSED ");
+    }
+    printf("\n");
+#endif
+}
+
 void sizeof_test(void)
 {
     int a;
-- 
1.7.5.1

